/**********************************************************************
  Module: bullet.h
  Author: Micah Hanmin Wang

  Purpose: Manages both player's and caterpiller's bullets
  Stores the constants that the bullets needed.
  Declares the enemyBullet and playerBullet's struct

**********************************************************************/

#ifndef BULLET_H
#define BULLET_H

#include "enemy.h"
#include "player.h"
#include <stdio.h>
#include <curses.h>
#include <string.h>
#include <pthread.h>

#define BULLET_SIZE 1
#define BULLET_ANIM_TILES 1

#define UPPER_BOUNDARY 2

typedef struct playerBullet_struct 
{
	/* remember the start parameters internally */
	int startCol;
	int startRow;
    int animTile;

    bool hit;
    bool isDead; //TODO: delete it in upkeep thread
    
	int row;
	int col;

    player *p;
    
	pthread_t thread;
	pthread_mutex_t *mutex; //pointer to screenLock
	pthread_mutex_t *llist; //pointer to Lined List
} playerBullet;

typedef struct enemyBullet_struct 
{
	/* remember the start parameters internally */
	int startCol;
	int startRow;
    int animTile;

    bool hit;
    bool isDead; //TODO: delete it in upkeep thread

    player *p;
    
	int row;
	int col;
    
	pthread_t thread;
	pthread_mutex_t *mutex; //pointer to screenLock
	pthread_mutex_t *llist; //pointer to Lined List
} enemyBullet;

void newEnemyBullet(enemyBullet *eb);
void newPlayerBullet(playerBullet *pb);
void *runEnemyBullet(void *data);
void *runPlayerBullet(void *data);

#endif/**********************************************************************
  Module: centipede.h
  Author: Micah Hanmin Wang

  Stores the constants that the main program (centipede.c) needs, such 
  as the keyboard strokes.

**********************************************************************/

#ifndef EXAMPLE_H
#define EXAMPLE_H

#include "console.h"
#include "centipede.h"
#include "player.h"
#include "enemy.h"
#include "llist.h"
#include "bullet.h"
#include "gameglobals.h"

#define KEY_W_PREESSED 'w'
#define KEY_A_PREESSED 'a'
#define KEY_S_PREESSED 's'
#define KEY_D_PREESSED 'd'
#define SPACE_PREESSED ' '
#define KEY_Q_PREESSED 'q'
#define PLAYER_BOUNDARY_ROW 17

#define ENEMY_HEIGHT 2
#define ENEMY_WIDTH 80

#define PLAYER_START_ROW 20
#define PLAYER_START_COL 36
#define PLAYER_INIT_LIVES 4

void *runKeyboard(void *data);

void *runConsoleRefresh(void *data);

void *runSpawnThread(void *data);

void centipedeRun();

void cleanUp(player *p);

#endif
/**********************************************************************
  Module: console.h
  Author: Daniel Rea

  Purpose: Draw 2d images on the screen.  Also, draw main game image.

  NOTES: none of these functions are re-entrant (they are not thread
	 		safe). 
**********************************************************************/

#ifndef CONSOLE_H
#define CONSOLE_H
#define _GNU_SOURCE

#include <stdbool.h>

/**************** DRAWING **************************/

/* directions in terms of deltas in x / y dimension */
#define LEFT -1
#define RIGHT 1
#define UP -1
#define DOWN 1

#define SCR_LEFT 0
#define SCR_TOP 0

/* Initialize curses, draw initial gamescreen. Refreshes console to terminal. 
 Also stores the requested dimensions of the consoe and tests the terminal for the
 given dimensions.*/
extern bool consoleInit(int reqHeight, int reqWidth, char *image[]);

/* Draws 2d `image' of `height' rows, at curses coordinates `(row, col)'.
   Note: parts of the `image' falling on negative rows are not drawn; each
   row drawn is clipped on the left and right side of the game console (note
   that `col' may be negative, indicating `image' starts to the left of the
   screen and will thus only be partially drawn. Useful for objects that are
   half off the screen  */
extern void consoleDrawImage(int row, int col, char *image[], int height);

/* Clears a 2d `width'x`height' rectangle with spaces.  Upper left hand
   corner is curses coordinate `(row,col)'. */
extern void consoleClearImage(int row, int col, int height, int width);

/* Moves cursor to bottom right corner and refreshes. If this is not done,
   the curses internal buffer (that you have been drawing to) is not dumped
   to screen. */
extern void consoleRefresh(void);

/*  turns off all updates. Can be used to prevent the screen refresh from working, e.g., at game end while threads are all catching up.*/
extern void disableConsole(int disabled);

/* Terminates curses cleanly. */
extern void consoleFinish(void);

/* Puts the given banner in the center of the screen */
void putBanner(const char *);

/* Draws the given string at the given location  */
void putString(char *, int row, int col, int maxlen);

/* Sleeps the given number of 20ms ticks */
void sleepTicks(int ticks);

/* clears the input buffer and then waits for one more key */
void finalKeypress();

/* gets a timespec that represents the time of one tick */
struct timespec getTimeout(int ticks);

#endif /* CONSOLE_H */
/**********************************************************************
  Module: constants.h
  Author: Micah Hanmin Wang

  This is a constant library, storing all the constants across all the 
  files needed.
  Unfortunately, I don't time to integrate this library for the rest of 
  my files, but at least I have the intent to use a constant library 
  like this.

**********************************************************************/


/****************CENTIPEDE.C****************/
#define KEY_W_PREESSED 'w'
#define KEY_A_PREESSED 'a'
#define KEY_S_PREESSED 's'
#define KEY_D_PREESSED 'd'
#define SPACE_PREESSED ' '
#define KEY_Q_PREESSED 'q'
#define PLAYER_BOUNDARY_ROW 17
#define ENEMY_HEIGHT 2
#define ENEMY_WIDTH 80
#define PLAYER_START_ROW 20
#define PLAYER_START_COL 36
#define PLAYER_INIT_LIVES 4
char *GAME_BOARD[] = {
"                   Score:    0     Lives:    4",
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-centipiede!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
"",
"",
"",
"",
"",
"", 
"" };



/****************GAMEGLOBALS.H****************/
#define BUF_SIZE 10
#define UPKEEP_ROW 0
#define SCORE_POS 29
#define LIVES_POS 45
#define BULLET_SIZE 1




/****************PLAYER.H****************/
#define PLAYER_ANIM_TILES 3
#define PLAYER_ANIM_TICKS 30
#define PLAYER_WIDTH 5 
#define PLAYER_HEIGHT 4 



/****************ENEMY.H****************/
#define ENEMY_HEIGHT 2
#define ENEMY_WIDTH 80
#define ENEMY_BODY_ANIM_TILES 4 
#define NUM_THREADS 1
#define ENEMY_MIN_WIDTH 4
#define LOWER_ROW_BOUNDARY 14
#define COL_BOUNDARY 80
#define LAST_ROW 14
#define ENEMY_FIRST_ROW 2
#define ENEMY_SPEED 40
char* ENEMY_BODY_LEFT[ENEMY_BODY_ANIM_TILES][ENEMY_HEIGHT] = 
{
    {"@|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||",
    "=;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,"},
    {"@||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^",
    "=;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;"},
    {"@|^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|",
    "=,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;"},
    {"-^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^||",
    "=;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;"}
};

char* ENEMY_BODY_RIGHT[ENEMY_BODY_ANIM_TILES][ENEMY_HEIGHT] = 
{
    {"|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||@",
    ";;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,="},
    {"^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^||-",
    ";;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;="},
    {"|^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|@",
    ",;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;="},
    {"||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^@",
    ";,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;="}
};



/****************BULLET.H****************/
#define BULLET_SIZE 1
#define BULLET_ANIM_TILES 1
#define UPPER_BOUNDARY 2
char* PLAYER_BULLET[BULLET_SIZE][BULLET_ANIM_TILES] = 
{
   {"|"}
};
char* ENEMY_BULLET[BULLET_SIZE][BULLET_ANIM_TILES] = 
{
   {"."}
};


/****************LLIST.H****************/
#define ENEMY_MIN_WIDTH 4
#define MIN_SPAWN_TICK 8000
#define MAX_SPAWN_TICK 10000/**********************************************************************
  Module: enemy.h
  Author: Micah Hanmin Wang

  Purpose: Manages the invaders (aka enemies, centipedes, caterpillers)
  Stores the constants that the enemy threads needed.
  Declares the enemy struct

**********************************************************************/

#ifndef ENEMY_H
#define ENEMY_H

#define ENEMY_HEIGHT 2
#define ENEMY_WIDTH 80
#define ENEMY_BODY_ANIM_TILES 4 
#define NUM_THREADS 1
#define ENEMY_MIN_WIDTH 4

#define LOWER_ROW_BOUNDARY 14
#define COL_BOUNDARY 80
#define LAST_ROW 14
#define ENEMY_FIRST_ROW 2

#define ENEMY_SPEED 40

#include "player.h"
#include "console.h"
#include "threadwrappers.h"
#include <pthread.h>
#include <stdbool.h>
#include <stdlib.h>

typedef struct enemy_struct 
{
	/* remember the start parameters internally */
	int startCol;
	int startRow;

	bool isDead;
    bool isHit;

    int length;
    int speed;
    char* direction;

    player *p;
    
	int row;
	int col;
	int animTile;
    
	pthread_t thread;
	pthread_mutex_t *mutex; //pointer to screenLock
    pthread_mutex_t *enemyLock;
} enemy;

void newEnemy(enemy *e);
void *runEnemy(void *data);

#endif/**********************************************************************
  Module: gameglobals.h
  Author: Micah Hanmin Wang

  Stores the constants that the Upkeep threads need.

**********************************************************************/

#include "console.h"
#include "centipede.h"
#include "player.h"
#include "enemy.h"
#include "bullet.h"

#define BUF_SIZE 10
#define UPKEEP_ROW 0
#define SCORE_POS 29
#define LIVES_POS 45
#define BULLET_SIZE 1

void *runUpkeep(void *data);/**********************************************************************
  Module: llist.h
  Author: Micah Hanmin Wang

  Purpose: Manages caterpiller linked list and bullet linked list
  Stores the constants that these two linked lists needed.
  Declares caterpiller's and bullet's linked lists struct

**********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "enemy.h"
#include "bullet.h"
#include "threadwrappers.h"

#define ENEMY_MIN_WIDTH 4
#define MIN_SPAWN_TICK 8000
#define MAX_SPAWN_TICK 10000

// A Linked List
typedef struct node
{
    enemy *e;
    struct node *next;
} enemyNode;

// A Linked List
typedef struct nod
{
    enemyBullet *eb;
    playerBullet *pb;
    struct nod *next;
} BulletNode;

void spawnEnemy(int startRow, int startCol, int length, char* direction, bool spawn, player *p, pthread_mutex_t *screenLock);
struct node* createEnemyQueue(enemy *e);
void insertEnemyQueue(enemy *e, enemyNode *enemyQueue);
void deleteEnemy(enemy *e);
enemyNode* getEnemyQueue();

void spawnEnemyBullet(int startRow, int startCol, player *p, pthread_mutex_t *screenLock);
void spawnPlayerBullet(int startRow, int startCol, player *p, pthread_mutex_t *screenLock);
BulletNode* createBulletQueue(playerBullet *pb, enemyBullet *eb);
void insertBulletQueue(playerBullet *pb, enemyBullet *eb, BulletNode *BulletQueue);
void deleteBullet(playerBullet *pb, enemyBullet *eb);
BulletNode* getBulletQueue();/**********************************************************************
  Module: player.h
  Author: Micah Hanmin Wang

  Purpose: manages the player's ship for invaders
  Stores the constants that the Upkeep threads need.

**********************************************************************/

#ifndef PLAYER_H
#define PLAYER_H

#define PLAYER_ANIM_TILES 3
#define PLAYER_ANIM_TICKS 30
#define PLAYER_WIDTH 5 
#define PLAYER_HEIGHT 4 

#include "console.h"
#include "threadwrappers.h"
#include <pthread.h>
#include <stdbool.h>
#include <stdlib.h>


typedef enum playerState_enum 
{
	GAME, // In game
	DEAD, // Player dead
	GAMEOVER // player win
} playerState; 

typedef struct player_struct 
{
	/* remember the start parameters internally */
	int startCol;
	int startRow;

	playerState state;

	bool running;
	int lives;
	int score;
	int row;
	int col;
	int animTile;
	pthread_t thread;
	pthread_mutex_t *mutex; //pointer to screenLock
	pthread_cond_t  *cond_cv;
} player;

void *runPlayerT(void *data);

player* spawnPlayer(int startRow, int startCol, int lives, pthread_mutex_t *screenLock, pthread_cond_t *cond_cv);

/* thread safe for player & ALSO LOCKS SCREEN */
//yours may or may not lock the screen on call.
void playerMove(player *f, int dRow, int dCol); 

/* NOT thread safe */
/* removes a life, ends the game if all lives gone */
//students: I actually left this as not thread safe in my final solution
//and I made sure it was used in a thread safe way
void killPlayer(player* p);

#endif/**********************************************************************
  Module: threadwrappers.h
  Author: Daniel Rea

  Purpose: error-checking wrappers for pthread functions
	For distribution to students. Not all functions implemented.
	This is just from my solution with parts removed. 
  Treat it as a guide. Feel free to implement,
	change, remove, etc, in your own solution.

**********************************************************************/

#ifndef THREADWRAPPERS_H
#define THREADWRAPPERS_H

#include <pthread.h>

int wrappedMutexLock(pthread_mutex_t *mutex);
int wrappedMutexUnlock(pthread_mutex_t *mutex);
int wrappedMutexInit(pthread_mutex_t  *mutex,  const  pthread_mutexattr_t *mutexattr);

int wrappedPthreadCreate(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);
int wrappedPthreadJoin(pthread_t thread, void **retval);

int wrappedCondSignal(pthread_cond_t *cond);

int wrappedCondWait(pthread_cond_t *cond, pthread_mutex_t *mutex);


#endif /* THREADWRAPPERS_H*/
/**********************************************************************
  Module: bullet.c
  Author: Micah Hanmin Wang

  Contains two initialize functions. One for enemy bullets, one for player
  bullets.
  Also contains two threading functions, one for enemy bullets, one for 
  player bullets.

  Purpose: Manages every single bullets in their threads, 
  make sure they are thread safe.

**********************************************************************/

#include "bullet.h"
#include "llist.h"
#include <stdio.h>
#include <curses.h>
#include <string.h>
#include <pthread.h>

char* PLAYER_BULLET[BULLET_SIZE][BULLET_ANIM_TILES] = 
{
   {"|"}
};

char* ENEMY_BULLET[BULLET_SIZE][BULLET_ANIM_TILES] = 
{
   {"."}
};

/********************support functions***************/
/* Initialize the enemy bullet. Including its positions */
void newEnemyBullet(enemyBullet *eb) 
{
	eb->row = eb->startRow;
	eb->col = eb->startCol;
	eb->animTile = 0;
}

/* Initialize the player bullet. Including its positions */
void newPlayerBullet(playerBullet *pb) 
{
	pb->row = pb->startRow;
	pb->col = pb->startCol;
	pb->animTile = 0;
}

/********************THREAD functions***************/

/********************************************************** 
    The Enemy (aka caterpillar) Bullet Thread function.
    Initialize the new enemy bullet and body strings.
    Manages it while it's living and decide when it's about to die.
    Has the logic for enemy bullet to move, and when to die.
    When it hits the bottom boundary or hits the player, it dies.
 **********************************************************/
void *runEnemyBullet(void *data) {
    enemyBullet* eb = (enemyBullet*)data;
    newEnemyBullet(eb);
    while(eb->p->running && eb->p->lives > 0) {
        char** enemy_bullet_tile = ENEMY_BULLET[BULLET_ANIM_TILES-1]; /* Enemy bullet's body */

        wrappedMutexLock(eb->mutex);
        consoleClearImage(eb->row, eb->col, BULLET_SIZE, BULLET_SIZE); // Clear enemy bullet's prev position
        if(eb->row >= eb->p->row) {
            /* Enemy bullet didn't hit player, it's about to go out of the lower boundary */
            eb->isDead = true;
            wrappedMutexUnlock(eb->mutex);
            //wrappedMutexLock(eb->llist);
            deleteBullet(NULL, eb); //TODO: delete this bullet from linked list
            //wrappedMutexUnlock(eb->llist);
            break;
        }
        else {
            /* If it didn't hit player, continue going down then */
            eb->row = eb->row+1;
        }
        consoleDrawImage(eb->row, eb->col, enemy_bullet_tile, BULLET_SIZE); // Draw the bullet in the new position
        wrappedMutexUnlock(eb->mutex);

        if(eb->row == eb->p->row-1 && (eb->col == eb->p->col || eb->col == eb->p->col+1 || eb->col == eb->p->col+2 || eb->col == eb->p->col+3 || eb->col == eb->p->col+4)) {
            /* The player got hit by the bullet */
            killPlayer(eb->p);
            wrappedMutexLock(eb->mutex);
            consoleClearImage(eb->row, eb->col, BULLET_SIZE, BULLET_SIZE); // Clear bullet when it hits the player
            wrappedMutexUnlock(eb->mutex);
            eb->isDead = true;
            //wrappedMutexLock(eb->llist);
            deleteBullet(NULL, eb); //TODO: delete this bullet from linked list
            //wrappedMutexUnlock(eb->llist);
            break;
        }

        sleepTicks(6); // Speed of the bullet
    }
    pthread_exit(NULL);
}

/********************************************************** 
    The Player Bullet Thread function.
    Initialize the new player bullet and body strings.
    Manages it while it's living and decide when it's about to die.
    Has the logic for player bullet to move, and when to die.
    When it hits the upper boundary or hits any caterpillers, it dies.
 **********************************************************/
void *runPlayerBullet(void *data) {
    playerBullet* pb = (playerBullet*)data;
    newPlayerBullet(pb);
    pb->p->score = pb->p->score + 1;
    while(pb->p->running && pb->p->lives > 0) {
        char** player_bullet_tile = PLAYER_BULLET[BULLET_ANIM_TILES-1];

        /********************************************************** 
            This is detecting if the player bullet hits any caterpillers
            by going through each caterpiller when it moves
        **********************************************************/
        enemyNode *enemyList = getEnemyQueue();
        while(enemyList != NULL) {
            if(strcmp(enemyList->e->direction, "left") == 0) {
                /* If the player bullet hits the enemy going right to left */
                if(pb->row == enemyList->e->row+2 && (pb->col >= enemyList->e->col && pb->col <= enemyList->e->col + enemyList->e->length)){
                    pb->p->score = pb->p->score + 20; // Centipede's been hit, update player's score.
                    int length = enemyList->e->length;
                    enemyList->e->length = pb->col - enemyList->e->col; // Update previous enemy's length
                    enemyList->e->isHit = true;
                    /* Spawn new caterpiller based on its new position and new length, inherits the direction from another caterpiller, though. */
                    spawnEnemy(enemyList->e->row, pb->col+3, length-(pb->col - enemyList->e->col), enemyList->e->direction, false, pb->p, pb->mutex); // Spawn a new enemy on the pb cut
                    pb->isDead = true; // Turn the isDead flag on for the previous enemy to speed up

                    //wrappedMutexLock(pb->llist);
                    deleteBullet(pb, NULL); //TODO: delete this bullet from linked list
                    //wrappedMutexUnlock(pb->llist);
                    pthread_exit(NULL);
                }
            }
            else { //right
                /* If the player bullet hits the enemy going left to right */
                if(pb->row == enemyList->e->row+2 && (pb->col <= enemyList->e->col && pb->col >= enemyList->e->col - enemyList->e->length)){
                    pb->p->score = pb->p->score + 20; // Centipede's been hit, update player's score.
                    enemyList->e->isHit = true;
                    /* Spawn new caterpiller based on its new position and new length, inherits the direction from another caterpiller, though. */
                    spawnEnemy(enemyList->e->row, pb->col-2, enemyList->e->length-(enemyList->e->col - pb->col), enemyList->e->direction, false, pb->p, pb->mutex);
                    enemyList->e->length = enemyList->e->col - pb->col; // Update previous enemy's length
                    pb->isDead = true; // Turn the isDead flag on for the previous enemy to speed up
                    //wrappedMutexLock(pb->llist);
                    deleteBullet(pb, NULL); //TODO: delete this bullet from linked list
                    //wrappedMutexUnlock(pb->llist);
                    pthread_exit(NULL);
                }
            }
            enemyList = enemyList->next; // Iterate through enemy list
        }

        wrappedMutexLock(pb->mutex);
        consoleClearImage(pb->row, pb->col, BULLET_SIZE, BULLET_SIZE); // Clear
        if(pb->row <= UPPER_BOUNDARY) {
            // If the bullet get passed enemy and is out of the boundary
            pb->isDead = true;
            wrappedMutexUnlock(pb->mutex);
            //wrappedMutexLock(pb->llist);
            deleteBullet(pb, NULL); //TODO: delete this bullet from linked list
            //wrappedMutexUnlock(pb->llist);
            break;
        }
        else {
            // Otherwise, Player bullet continues to go upwards.
            pb->row = pb->row-1;
        }
        consoleDrawImage(pb->row, pb->col, player_bullet_tile, BULLET_SIZE); // Draw
        wrappedMutexUnlock(pb->mutex);

        sleepTicks(6); // Speed of the bullet
    }
    pthread_exit(NULL);
}

/**********************************************************************
  Module: centipede.c
  Author: Micah Hanmin Wang

  Purpose: the core source file for the game engine. This manages the
  thread initialization of all parts, provides functions for global lock
  coordination for the screen, initializes all the threads needed for the 
  main game loop, and helps synchronize threads when necessary.

  The main game loop sleeps and waits for when the game ends (either player wins,
  loses, or the game quits)

  Includes thread functions for: keyboard thread, refresh thread, enemy spawn
  thread and upkeep thread.

**********************************************************************/
#include "centipede.h"
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <stdio.h>
#include <sys/select.h>


//all these constants and gameboard should probably go in a constants file...hint hint
#define GAME_ROWS 24
#define GAME_COLS 80

/**** INITIAL GAMEBOARD */
char *GAME_BOARD[] = {
"                   Score:    0     Lives:    4",
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-centipiede!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
"",
"",
"",
"",
"",
"", 
"" };

/* The one, true, screen lock that will control each thread's drawing to the screen */
pthread_mutex_t screenLock;

/* keyboard thread */
pthread_t keyboard_thread;
/* keyboard thread's mutex */
pthread_mutex_t keyboard_mutex;
/* refresh thread */
pthread_t refresh_thread;
/* refresh thread's mutex */
pthread_mutex_t refresh_mutex;
/* spawn thread */
pthread_t spawn_thread;
/* upkeep thread */
pthread_t upkeep_thread;
/* upkeep thread's mutex */
pthread_mutex_t upkeep_mutex;

/* The condition variable mutex */
pthread_mutex_t cond_mutex;
/* The condition variable which waits for the game to end */
pthread_cond_t  cond_cv;

/********************************************************** 
    Keyboard Thread function.
    Reads keyboard input and move the player
    or shoots the bullets
    and detects if 'Q' is pressed to quit the game.
    Checks if the game ends regularly to stop waiting for
    getchar().
 **********************************************************/
void *runKeyboard(void* data) {
    /* Pass the reference to the player p */
    player* p = (player*)data;

    fd_set rfds;
    struct timeval tv;
    int retval;

    /* Watch stdin (fd 0 to see when it has input. */
    FD_ZERO(&rfds);
    FD_SET(0, &rfds);

    /* Wait up to 1 seconds. */
    tv.tv_sec = 1;
    tv.tv_usec = 0;

    while(p->running && p->lives > 0) {
        retval = select(1, &rfds, NULL, NULL, &tv);
        if (retval == -1) {
            perror("select()");
            exit(EXIT_FAILURE);
        }
        else {
            if(p->state == DEAD) {
                /* Disable the keyboard input for 1s if the player being shot */
                sleep(1);
            }
            /* FD_ISSET(0, &rfds) is true so input is available now. */
            char input;
            /* Get input from the keyboard */
            input = getchar(); // TODO: NO, THIS IS NOT PERFECT, GAME STILL WAITING FOR THIS

            int prevRow = p->row;
            int prevCol = p->col;

            switch(input) {
                case KEY_W_PREESSED:
                        /* Player going up 1 row */
                        if(p->row > PLAYER_BOUNDARY_ROW) {
                                /* Update player's pos */
                                p->row = p->row - 1;
                        }
                        break;
                case KEY_A_PREESSED:
                        /* Player going left 1 col */
                        if(p->col > 0) {
                                p->col = p->col - 1;
                        }
                        break;
                case KEY_S_PREESSED:
                        /* Player going down 1 row */
                        if(p->row < GAME_ROWS-PLAYER_HEIGHT) {
                                /* Update player's pos */
                                p->row = p->row + 1;
                        }
                        break;
                case KEY_D_PREESSED:
                        /* Player going up 1 row */
                        if(p->col < GAME_COLS-PLAYER_WIDTH) {
                                /* Update player's pos */
                                p->col = p->col + 1;
                        }
                        break;
                case SPACE_PREESSED:
                        /* Shoot player bullet from its head */
                        spawnPlayerBullet(p->row-1, p->col+2, p, &screenLock);
                        break;
                case KEY_Q_PREESSED:
                        wrappedMutexLock(&screenLock);
                        /* Put the quitter banner onto the screen if 'Q' being pressed */
                        putBanner("quitter....");
                        wrappedMutexUnlock(&screenLock);
                        wrappedCondSignal(&cond_cv);
                        break;
                default:
                        break;
            }
            /* Move player with the updated player's pos */
            playerMove(p, prevRow, prevCol);
        }
    }
    if(p->lives == 0) {
        /* Player loses, put the game over banner onto the screen */
        wrappedMutexLock(&screenLock);
        putBanner("game over...Do, or do not.. there is no try!");
        wrappedMutexUnlock(&screenLock);
        /* Send the signal to kill the game & clean up */
        wrappedCondSignal(&cond_cv);
    }
    pthread_exit(NULL);
}

/********************************************************** 
    Refresh Thread function.
    A really simple refresh thread.
    Performs refresh() every 1 tick, to get the update from
    the screen buffer onto the screen.
 **********************************************************/
void *runConsoleRefresh(void *data) {
        player* p = (player*)data;
        while(p->running && p->lives > 0) {
                wrappedMutexLock(&screenLock);
                consoleRefresh();
                wrappedMutexUnlock(&screenLock);
                sleepTicks(1);
        }
        pthread_exit(NULL);
}

/********************************************************** 
    Enemy Spawn Thread function.
    Calls the spawnEnemy() function to spawn the enemy at a 
    random time (8000 - 10000 ticks)
    This thread function does not have a loop, it only performs 
    one time, because the while loop is in the spawnEnemy() function.
 **********************************************************/
void *runSpawnThread(void *data) {
        player* p = (player*)data;
        /* Spawn 1 enemy for now. It starts from the upper right corner with the direction left */
        spawnEnemy(ENEMY_HEIGHT, ENEMY_WIDTH, ENEMY_WIDTH, "left", true, p, &screenLock);
        pthread_exit(NULL);
}

/********************************************************** 
    The main game mechanism function.
    Initialize the game board, needed locks and threads
    Then waits (sleeps) on a condition variable.
    If the signal is caught, it is woken up and do the clean
    up works.
 **********************************************************/
void centipedeRun()
{
        /* Initialize the game board */
	if (consoleInit(GAME_ROWS, GAME_COLS, GAME_BOARD))
        {
                /* Initialize screenLock */
                wrappedMutexInit(&screenLock, NULL);

                /* Initialize player on the screen. startRow=20, startColumn=36, lives=4 */
                player *p = spawnPlayer(PLAYER_START_ROW, PLAYER_START_COL, PLAYER_INIT_LIVES, &screenLock, &cond_cv);

                /* Initialize the spawn thread on the screen. startRow=0, startColumn=80 */
                wrappedPthreadCreate(&(spawn_thread), NULL, runSpawnThread, (void*)p);

                wrappedMutexInit(&keyboard_mutex, NULL);
                /* Initialize keyboard thread */
                wrappedPthreadCreate(&(keyboard_thread), NULL, runKeyboard, (void*)p);

                wrappedMutexInit(&refresh_mutex, NULL);
                /* Initialize refresh thread */
                wrappedPthreadCreate(&(refresh_thread), NULL, runConsoleRefresh, (void*)p);

                wrappedMutexInit(&upkeep_mutex, NULL);
                /* Initialize the upkeep thread */
                wrappedPthreadCreate(&(upkeep_thread), NULL, runUpkeep, (void*)p);              

                pthread_cond_init(&cond_cv, NULL);
                wrappedMutexInit(&cond_mutex, NULL);
                wrappedMutexLock(&cond_mutex);
                /* Sleeps on a condition variable */
                wrappedCondWait(&cond_cv, &cond_mutex);
                wrappedMutexUnlock(&cond_mutex);

                /* After woken up, clean up all the threads and memories */
                cleanUp(p);
                /* wait for final key before killing curses and game */
                finalKeypress();

        }
        consoleFinish();
}

/********************************************************** 
    Does the clean up work when the game ends (quit, win, lose).
    Joins:
    1. Player thread
    2. Keyboard thread
    3. Refresh thread
    4. Upkeep thread
    5. Enemy Spawn thread
    6. Enemy threads
    7. Player & Enemy Bullet threads
    And destroys all mutexes, and the condition variable
    Also frees all the malloced memories.
 **********************************************************/
void cleanUp(player *p) {
        p->running = false;

        pthread_cancel(p->thread);
        pthread_join(p->thread, NULL); // Join the only player thread
        pthread_cancel(keyboard_thread);
        pthread_join(keyboard_thread, NULL); // Join the only keyboard thread
        pthread_cancel(refresh_thread);
        pthread_join(refresh_thread, NULL); // Join the only refresh thread
        pthread_cancel(upkeep_thread);
        pthread_join(upkeep_thread, NULL); // Join the only upkeep thread
        pthread_cancel(spawn_thread);
        pthread_join(spawn_thread, NULL); // Join the only spawn thread

        enemyNode *enemyList = getEnemyQueue();
        while(enemyList != NULL) {
                pthread_cancel(enemyList->e->thread);
                pthread_join(enemyList->e->thread, NULL);
                free(enemyList->e);
                enemyList = enemyList -> next;
        }

        BulletNode *bulletList = getBulletQueue();
        while(bulletList != NULL) {
                if(bulletList->eb != NULL) {
                        pthread_cancel(bulletList->eb->thread);
                        pthread_join(bulletList->eb->thread, NULL);
                        free(bulletList->eb);
                }
                else if(bulletList->pb != NULL) {
                        pthread_cancel(bulletList->pb->thread);
                        pthread_join(bulletList->pb->thread, NULL);
                        free(bulletList->pb);
                }
                bulletList = bulletList -> next;
        }

        pthread_mutex_destroy(&cond_mutex);
        pthread_cond_destroy(&cond_cv);

        pthread_mutex_destroy(&keyboard_mutex);
        pthread_mutex_destroy(&refresh_mutex);
        pthread_mutex_destroy(&upkeep_mutex);

        pthread_mutex_destroy(&screenLock);

        free(enemyList);
        free(bulletList);
        free(p);
}

#include "console.h"
#include <curses.h>
#include <string.h>
#include <time.h>        /*for nano sleep */

static int CON_WIDTH, CON_HEIGHT;
static int consoleLock = false;
static int MAX_STR_LEN = 256; /* for strlen checking */

/* Local functions */

/* Check if the current console is larger than the
    dimension defined in centipede.c 
    If not print an error; if yes, then proceed. */
static bool checkConsoleSize(int reqHeight, int reqWidth) 
{

	if ( (reqWidth > COLS) || (reqHeight > LINES) ) 
 	{
    	fprintf(stderr, "\n\n\rSorry, your window is only %ix%i. \n\r%ix%i is required. Sorry.\n\r", COLS, LINES, reqWidth, reqHeight);
    	return (false);
  	}

  return(true);
}

/* Return success if the console dimension meets requirement */
bool consoleInit(int height, int width, char* board[]) {
    bool status;

    initscr();
	crmode();
	noecho();
	clear();

    CON_HEIGHT = height;
    CON_WIDTH = width;

    // Check if the user's console size fits
    status = checkConsoleSize(height, width);

    if(status) 
	{
        // If the user's console size fits, then draw the board
		consoleDrawImage(0, 0, board, CON_HEIGHT);
		consoleRefresh();
	}

    return status;

}

/* Draw the image board */
void consoleDrawImage(int row, int col, char *image[], int height) 
{
	int i, length;
	int newLeft, newRight, newOffset, newLength;

	if (consoleLock) return;

	newLeft  = col < 0 ? 0 : col;
	newOffset = col < 0 ? -col : 0;

	for (i = 0; i < height; i++) 
	{
		if (row+i < 0 || row+i >= CON_HEIGHT)
			continue;
		length = strnlen(image[i], MAX_STR_LEN);
		newRight = col+length >= CON_WIDTH ? CON_WIDTH-1 : col+length;
		newLength = newRight - newLeft + 1;
		if (newOffset >= length || newLength <= 0)
		  continue;

		if (mvaddnstr(row+i, newLeft, image[i]+newOffset, newLength) == ERR)
			fprintf(stderr, "ERROR drawing to screen"); /* smarter handling is needed */
	}
}

void consoleClearImage(int row, int col, int height, int width) 
{
	int i, j;
	if (consoleLock) return;

	if (col+width > CON_WIDTH)
		width = CON_WIDTH-col;
	if (col < 0) 
	{
		width += col; /* -= -col */
		col = 0;
	}

	if (width < 1 || col >= CON_WIDTH) /* nothing to clear */
		return;

	for (i = 0; i < height; i++) 
	{
		if (row+i < 0 || row+i >= CON_HEIGHT)
			continue;
		move(row+i, col);
		for (j = 0; j < width; j++)
	    		addch(' ');
	}
}

void consoleRefresh(void)
{
	if (!consoleLock) 
	{
	    move(LINES-1, COLS-1);
	    refresh();
	}
}

void consoleFinish(void) 
{
    endwin();
}

void putBanner(const char *str) 
{
  if (consoleLock) return;
  int len;

  len = strnlen(str,MAX_STR_LEN);
  
  move (CON_HEIGHT/2, (CON_WIDTH-len)/2);
  addnstr(str, len);

  consoleRefresh();
}

void putString(char *str, int row, int col, int maxlen) 
{
  if (consoleLock) return;
  move(row, col);
  addnstr(str, maxlen);
}


/* setup to work in USECS, reduces risk of overflow */
/* 10000 usec = 10 ms, or 100fps */
#define TIMESLICE_USEC 10000
#define TIME_USECS_SIZE 1000000
#define USEC_TO_NSEC 1000  
struct timespec getTimeout(int ticks) 
{
  struct timespec rqtp;

  /* work in usecs at first */
  rqtp.tv_nsec = TIMESLICE_USEC * ticks;

  /* handle usec overflow */
  rqtp.tv_sec = rqtp.tv_nsec / TIME_USECS_SIZE;
  rqtp.tv_nsec %= TIME_USECS_SIZE;

  rqtp.tv_nsec *= USEC_TO_NSEC;  /*convert to nsecs */
  return rqtp;
}

void sleepTicks(int ticks) 
{

  if (ticks <= 0)
    return;

// Sleep for this amount of ticks (for player for now)
  struct timespec rqtp = getTimeout(ticks);
  nanosleep(&rqtp, NULL);
}

#define FINAL_PAUSE 2 
void finalKeypress() 
{
	flushinp();
	sleepTicks(FINAL_PAUSE);
    	move(LINES-1, COLS-1);
	getch(); /* wait for user to press a character, blocking. */
}

void disableConsole(int disabled) 
{
	consoleLock = disabled;
}
/**********************************************************************
  Module: enemy.c
  Author: Micah Hanmin Wang

  Contains all the functions related to the enemies (aka. centipede),
  including helper functions like initializing new enemies and reverse
  a string; also includes that big enemy thread function where all the 
  enemy moving logics are at.

  Purpose: Manages every single enemies, make sure they are thread safe.

**********************************************************************/

#include "enemy.h"
#include "llist.h"
#include <stdio.h>
#include <curses.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>

/********************support functions****************/

/********************************************************** 
    Reset the enemy state to start,
    Initialize enemy's initial position (row+col)
 **********************************************************/
void newEnemy(enemy *e) 
{
	e->row = e->startRow;
	e->col = e->startCol;
	e->animTile = 0;
}

/********************************************************** 
    reverse a string 
    e.g. hello -> olleh 
**********************************************************/
void strrev(char *str) {
    char *p1, *p2;
    for (p1=str, p2=str+strlen(str)-1; p2>p1; ++p1, --p2){
        *p1 ^= *p2;
        *p2 ^= *p1;
        *p1 ^= *p2;
    }
}

/********************THREAD function***************/

/********************************************************** 
    The Enemy (aka caterpillar) Thread function.
    Initialize the new caterpiller. Manages its animation tiles
    and body strings, performs cut on the body when needed.
    Has the logic for each enemy to move, and wraps appropriately, 
    whether it comes from left to right or right to left.
	If the enemy is too small (length < 5), it dies.
 **********************************************************/
void *runEnemy(void *data) {

    // Pass the reference to the player p
	enemy* e = (enemy*)data;
    //wrappedMutexInit(&e->enemyLock, NULL);
	/* RESET the player state to start */
	newEnemy(e);
	int i = 0; // aka. leftIncrementor. Call it i for simplicity, please don't deduct marks on the naming
    int j = 0; // aka. rightIncrementor. Call it j for simplicity, please don't deduct marks on the naming

    while(e->p->running && e->p->lives > 0) {
        /* If the player is being shot, freeze all centipedes for 2s */
        if(e->p->state == DEAD) {
            sleep(2);
        }
        /* Caterpiller's left body */
        char* ENEMY_BODY_LEFT[ENEMY_BODY_ANIM_TILES][ENEMY_HEIGHT] = 
        {
            {"@|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||",
            "=;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,"},
            {"@||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^",
            "=;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;"},
            {"@|^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|",
            "=,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;"},
            {"-^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^||",
            "=;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;"}
        };
        /* Caterpiller's right body */
        char* ENEMY_BODY_RIGHT[ENEMY_BODY_ANIM_TILES][ENEMY_HEIGHT] = 
        {
            {"|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||@",
            ";;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,="},
            {"^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^||-",
            ";;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;="},
            {"|^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|@",
            ",;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;="},
            {"||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^|||^@",
            ";,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;;;,;="}
        };
        e->animTile++;
		e->animTile %= ENEMY_BODY_ANIM_TILES;
        /* If the enemy's length < 5, then it will die and thread will exit */
        if(e->length <= ENEMY_MIN_WIDTH) {
            e->isDead = true;
            /* TODO */
            //deleteEnemy(e);
            pthread_exit(NULL);
        }

        char** tile_left = ENEMY_BODY_LEFT[e->animTile]; /* A temporary string for the enemy which goes from right to left */
        char** tile_right = ENEMY_BODY_RIGHT[e->animTile]; /* A temporary string for the enemy which goes from left to right */
        char tempArray[ENEMY_HEIGHT][e->length+1]; /* A temporary 2d string array for the cutted enemy which goes from left to right, if needed */

        if(e->length != ENEMY_WIDTH) {
            /* The enemy is hit and needs to have the anim tiles cut off. */
            /* This one is for right cut off */
            int height_index = 0; 
            int width_index = 0;
            for(height_index = 0; height_index < ENEMY_HEIGHT; height_index++) {
                char body_right[ENEMY_HEIGHT][ENEMY_WIDTH+1]={"0","0"}; /* The temp 2d string array for storing right body */
                int z = 0; /* right body's index, for reading the char in */
                for (width_index = 0; width_index < e->length; width_index++) {
                    /* Read the char from left body according to enemy's length, storing it into the temp array */
                    body_right[height_index][z] = tile_left[height_index][width_index];
                    z++;
                }
                body_right[height_index][z+1] = '\0'; // Add NULL terminator to the end of the string
                
                /* Copy the temp 2d string array into another 2d string array, to prevent overwriting on the left body */
                strcpy(tempArray[height_index], body_right[height_index]);
                
                /* Reverse the string to make it turn right */
                strrev(tempArray[height_index]);
                
                /* Pass the reference to the right body, completing cutting the right string body */
                tile_right[height_index] = tempArray[height_index];
            }

            /* This one is for left cut off */
            height_index = 0;
            width_index = 0;
            for(height_index = 0; height_index < ENEMY_HEIGHT; height_index++) {
                char body_left[ENEMY_HEIGHT][ENEMY_WIDTH+1]; /* The temp 2d string array for storing left body */
                for (width_index = 0; width_index < e->length; width_index++) {
                    /* Read the char from left body according to enemy's length, storing it into the temp array */
                    body_left[height_index][width_index] = tile_left[height_index][width_index];
                }
                body_left[height_index][width_index+1] = '\0'; // Add NULL terminator to the end of the string
                tile_left[height_index] = body_left[height_index]; /* Pass the reference to the left body, completing cutting the left string body */
            }
        }

        /* If the caterpiller is going from left to right */
        if(strcmp(e->direction, "right") == 0) {
            
            /********************************************************** 
                This is for cleaning the wrapping body on the prevRow,
                if the enemy is going from left to right.
            **********************************************************/
            if(e->startRow == e->row) {
                /* Remember we use startRow as 'prevRow'
                   If the startRow == current row
                   This means this caterpiller is being CUT while WRAPPING, so startRow is not meant as a prevRow. It's its new row.
                   Hence, we should handle the turning body on the previous row in a different calculation */
                wrappedMutexLock(e->mutex);
                // e->startRow-2 is the previous row, -e->col-1 is the previous caterpiller's col location
                consoleClearImage(e->startRow-2, -e->col-1, ENEMY_HEIGHT, e->length);
                // e->startRow-2 is the previous row, -(e->col+3) is the previous caterpiller's col location - 3
                // to create an illusion that it's still running on the previous row, KEKW
                consoleDrawImage(e->startRow-2, -(e->col+3), tile_left, ENEMY_HEIGHT);
                wrappedMutexUnlock(e->mutex);
            }
            else {
                /* Remember we use startRow as 'prevRow'
                   If the startRow != current row
                   This means this caterpiller is NOT being CUT while WRAPPING, so startRow is prevRow.
                   Hence, we just handle the wrapping body on the prevRow normally */
                wrappedMutexLock(e->mutex);
                // e->startRow is the previous row, -j+1 is the previous caterpiller's col location
                consoleClearImage(e->startRow, -j+1, ENEMY_HEIGHT, e->length);
                // e->startRow is the previous row, -(j+2) is the previous caterpiller's col location - 2
                // to create an illusion that it's still running on the previous row, KEKW
                consoleDrawImage(e->startRow, -(j+2), tile_left, ENEMY_HEIGHT);
                wrappedMutexUnlock(e->mutex);
            }
            
            /********************************************************** 
                This is for drawing the body on the currentRow
                if the enemy is going from left to right.
            **********************************************************/
            if(e->startCol != 0) {
                /* This drawing is for if the caterpiller is being cut */
                e->col = e->startCol+j;
                wrappedMutexLock(e->mutex);
                consoleClearImage(e->row, -(e->length)+e->col-1, ENEMY_HEIGHT, e->length); // Clear the prevCol
                consoleDrawImage(e->row, -(e->length)+e->col+1, tile_right, ENEMY_HEIGHT); // Draw on the nextCol
                wrappedMutexUnlock(e->mutex);
            }
            else {
                /* This drawing is for if the caterpiller is not being cut */
                wrappedMutexLock(e->mutex);
                consoleClearImage(e->row, -(e->length)+j-1, ENEMY_HEIGHT, e->length); // Clear the prevCol
                consoleDrawImage(e->row, -(e->length)+j+1, tile_right, ENEMY_HEIGHT); // Draw on the nextCol
                wrappedMutexUnlock(e->mutex);
                e->col = j; // Update e->col's position
            }
            

            srand(time(NULL));   // Initialization, should only be called once.
            if(rand()%10 == 0) {
                // Returns a pseudo-random integer between 0 and RAND_MAX.
                spawnEnemyBullet(e->row+1, e->col, e->p, e->mutex);
            }

            /* If the caterpiller going from left to right is hitting the right boundary (col=80) */
            if(j >= COL_BOUNDARY) {
                // The caterpiller is gonna taking a turn to the next row (new direction: right to left)
                e->col = j; // Update e->col to value 80 (j's current value), here, actually.
                e->startRow = e->row; //Update startRow. startRow is used as prevRow. <- REMEMBER THIS
                e->startCol = COL_BOUNDARY; // The caterpiller is gonna start at col=80 at next row.
                if(e->row != LAST_ROW) {
                    e->row = e->row + 2; // Get it to the next row
                }
                else {
                    e->row = LAST_ROW; // If caterpiller is already on the last row allowed, it's gonna repeat on this row
                }
                
                j = 0; // Clear the right incrementor to 0, for the next use
                e->direction = "left"; // The enemy is now turning left!
            }
            else {
                j++;
            }
            
        }
        /********************************************************** 
            This is for cleaning the wrapping body on the prevRow,
            if the enemy is going from right to left.
        **********************************************************/
        else {
            /* If the caterpiller going from right to left is not on ROW 2, then it must have a wrapping body on the prevRow. */
            if(e->row != ENEMY_FIRST_ROW) {
                if(e->startRow == e->row) {
                    /* This means this centipede is being cut, so startRow is not meant as a prevRow. It's its new row. */
                    /* Hence, we should handle the turning body on the previous row in a different calculation */
                    wrappedMutexLock(e->mutex);
                    // e->startRow-2 is the previous row, COL_BOUNDARY-e->length+i-1 is the previous centipede col location - 1
                    consoleClearImage(e->startRow-2, COL_BOUNDARY-e->length+i-1, ENEMY_HEIGHT, e->length); 
                    // e->startRow-2 is the previous row, COL_BOUNDARY-e->length+i+2 is the previous centipede col location - 2
                    // to create an illusion that it's still running on the previous row, KEKW
                    consoleDrawImage(e->startRow-2, COL_BOUNDARY-e->length+i+2, tile_right, ENEMY_HEIGHT);
                    wrappedMutexUnlock(e->mutex);
                }
                else {
                    /* Remember we use startRow as 'prevRow'
                        If the startRow != current row
                        This means this caterpiller is NOT being CUT while WRAPPING, so startRow is prevRow.
                        Hence, we just handle the wrapping body on the prevRow normally */
                    wrappedMutexLock(e->mutex);
                    // e->startRow is the previous row, COL_BOUNDARY-e->length+i-1 is the previous centipede col location
                    consoleClearImage(e->startRow, COL_BOUNDARY-e->length+i-1, ENEMY_HEIGHT, e->length); 
                    // e->startRow is the previous row, COL_BOUNDARY-e->length+i+2 is the previous centipede col location - 2
                    // to create an illusion that it's still running on the previous row, KEKW
                    consoleDrawImage(e->startRow, COL_BOUNDARY-e->length+i+2, tile_right, ENEMY_HEIGHT);
                    wrappedMutexUnlock(e->mutex);
                }
            }

            /********************************************************** 
                This is for drawing the body on the currentRow
                if the enemy is going from right to left.
            **********************************************************/
            wrappedMutexLock(e->mutex);
            consoleClearImage(e->row, e->col+1, ENEMY_HEIGHT, e->length); // e->col+1 is the current centipede location
            e->col = e->startCol-i-2; // Update e->col's position, e->startCol is the new location
		    consoleDrawImage(e->row, e->col, tile_left, ENEMY_HEIGHT);
            wrappedMutexUnlock(e->mutex);

            srand(time(NULL)); // Initialize randomizer
            if(rand()%10 == 0) {
                // Returns a pseudo-random integer between 0 and RAND_MAX.
                spawnEnemyBullet(e->row+2, e->col, e->p, e->mutex);
            }  
            
            /* If the caterpiller going from right to left is hitting the left boundary (col=0) */
            if(e->col <= 0) {
                // If the enemy hit the left wall in the last turn
                e->col = e->col-i-2; // Update e->col to value 0, here, actually.
                e->startRow = e->row; //Update startRow. startRow? More like prevRow!
                e->startCol = 0;
                if(e->row != LOWER_ROW_BOUNDARY){
                    e->row = e->row + 2; // Get it to the next row
                }
                else {
                    e->row = LOWER_ROW_BOUNDARY; // Get it to the next row
                }
                i = 0; // clear left incrementor value to 0, for the next use
                e->direction = "right"; // The enemy is now turning right!
            }
            else {
                i++;
            }
        }

        if(e->isHit) {
            /* Catch the isHit signal from player bullet thread, consume it by increasing the speed of this enemy. */
            if(e->speed == ENEMY_SPEED/2) {
                
            }
            else {
                /* Maximum speed: 40/2 */
                e->speed = e->speed/2;
            }
            e->isHit = false; // Turn off the hit flag
        }
        /* Control the caterpiller's speed */
		sleepTicks(e->speed);
	}
    return NULL;
}/**********************************************************************
  Module: gameglobals.c
  Author: Micah Hanmin Wang

  Purpose: Represents the upkeep threads in the game, to update scores &
  player's lives onto the screen (first row).
  And checks if there are any enemies left, if not, player wins.
  Also manages killing all the bullets when the player's being hit and game froze.

  Includes thread functions for: upkeep thread.

**********************************************************************/

#include "gameglobals.h"
#include <stdio.h>
#include <unistd.h>

/********************************************************** 
    Upkeep Thread function.
    Update scores & player's lives onto the screen (first row).
    And checks if there are any enemies left, if not, player wins.
    Also manages killing all the bullets when the player's being hit and game froze.
 **********************************************************/
void *runUpkeep(void *data) {
    player* p = (player*)data;
    char score[BUF_SIZE]; /* The buffer for storing score string */
    char lives[BUF_SIZE]; /* The buffer for storing player lives string */

    while (p->running && p-> lives > 0) {
        sprintf(score, "%d", p->score); // Convert int score to a string
        sprintf(lives, "%d", p->lives); // Convert int player lives to a string
        wrappedMutexLock(p->mutex);
        /* Put score onto the game board */
        putString(score, UPKEEP_ROW, SCORE_POS, BUF_SIZE);
        wrappedMutexUnlock(p->mutex);

        wrappedMutexLock(p->mutex);
        /* Put player lives onto the game board */
        putString(lives, UPKEEP_ROW, LIVES_POS, BUF_SIZE);
        wrappedMutexUnlock(p->mutex);

        sleepTicks(1); // This sleep tick is for if upkeep thread running faster than the spawn enemy thread, preventing automatic wins at the beginning of the game.
        /* TODO: Regularly check if there is no enemy left */
        enemyNode *enemyList = getEnemyQueue();
        bool gameover = true;
        while(enemyList != NULL){
            if(!enemyList->e->isDead) {
                gameover = false;
                break;
            }
            enemyList = enemyList-> next;
        }

        /* TODO: When the player is shot, remove all the bullets on the screen. */
        if(p->state == DEAD) {
            BulletNode *bulletList = getBulletQueue();
            while(bulletList != NULL) {
                if(bulletList->eb != NULL) {
                    wrappedMutexLock(p->mutex);
                    consoleClearImage(bulletList->eb->row, bulletList->eb->col, BULLET_SIZE, BULLET_SIZE);
                    wrappedMutexUnlock(p->mutex);
                    pthread_cancel(bulletList->eb->thread);
                    //pthread_join(bulletList->eb->thread, NULL);
                }
                else if(bulletList->pb != NULL) {
                    wrappedMutexLock(p->mutex);
                    consoleClearImage(bulletList->pb->row, bulletList->pb->col, BULLET_SIZE, BULLET_SIZE);
                    wrappedMutexUnlock(p->mutex);
                    pthread_cancel(bulletList->pb->thread);
                    //pthread_join(bulletList->pb->thread, NULL);
                }
                bulletList = bulletList -> next;
            }
            
        }
    }
    pthread_exit(NULL);
}/**********************************************************************
  Module: llist.c
  Author: Micah Hanmin Wang

  Contains the function for spawning enemy, and adds it to linked list 
  once a caterpiller thread is created.
  Also contains functions for spawning player bullet and enemy bullet, 
  same for the caterpiller ones, store them to the bullet linked list
  once created.

  Purpose: Manages spawning new enemy and adds enemy & both bullets to the
  linked list. Manages linked list (create, insert and delete from it)

**********************************************************************/

#include "llist.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <pthread.h>

enemyNode* enemyQueue; /* Caterpiller's Linked List */

BulletNode *bulletQueue; /* Linked List for both type of bullets */
pthread_mutex_t bulletListLock;
bool first = true; /* Flag for controlling if the caterpiller linked list is created or not */
pthread_mutex_t enemyListLock;

/********************************************************** 
    Initializing and creating new caterpiller and new caterpiller
    thread. Scheduling spawning new enemies and also create small
    ones after the original big caterpiller's being hit. 
 **********************************************************/
void spawnEnemy(int startRow, int startCol, int length, char* direction, bool spawn, player *p, pthread_mutex_t *screenLock)
{   
    while(p->running && p->lives > 0) {
        enemy* e = (enemy*)(malloc(sizeof(enemy)));
        /* error checking */
        if (e == NULL) {
            fprintf(stderr, "Fatal: failed to allocate %zu bytes.\n", sizeof(enemy));
            abort();
        }
        e->startCol = startCol; // Initialize the enemy's startCol
        e->startRow = startRow; // Initialize the enemy's startRow
        e->isDead = false;
        e->isHit = false;
        e->direction = direction;
        e->length = length; // Length of the enemy body. Could be deducted when hit!
        e->speed = ENEMY_SPEED; // Initialize the enemy speed to 40
        e->mutex = screenLock; // A reference to the screenlock
        e->p = p; // A reference to the player

        wrappedMutexInit(&enemyListLock, NULL);
        wrappedMutexInit(e->mutex, NULL);
        wrappedPthreadCreate(&(e->thread), NULL, runEnemy, (void*)e);

        /* If the enemy's length < 5, then it will die and thread will exit */
        if(e->length <= ENEMY_MIN_WIDTH) {
            /* CAUTION: This check is to prevent scheduling spawning new caterpillers when the original ones being cut */
            break;
        }
        else {
            if(first) {
                /* If the `first` flag is still on, then the enemy linked list is not created yet */
                enemyQueue = createEnemyQueue(e);
                first = false; // Turn off the flag
            }
            else {
                /* If the caterpiller Linked list is created, then ust insert the new one */
                insertEnemyQueue(e, enemyQueue);
            }
        }

        /* If this method is called by the spawn thread, it has the responsibility to spawn new enemy with length=80 */
        if(spawn) {
            sleepTicks(rand() % (MAX_SPAWN_TICK + 1 - MIN_SPAWN_TICK) + MIN_SPAWN_TICK); // Generate a new enemy randomly between ticks 8000-10000
        }
        else {
            /* If this method is not called by the spawn thread, it just spawns one enemy */
            break;
        }
    }
}

/********************************************************** 
    Just creates a new Caterpiller Linked List.
 **********************************************************/
enemyNode* createEnemyQueue(enemy *e) {
    enemyNode *newEnemyQueue = (enemyNode*)malloc(sizeof(enemyNode));
    /* error checking */
    if (newEnemyQueue == NULL) {
        fprintf(stderr, "Fatal: failed to allocate %zu bytes.\n", sizeof(enemyNode));
        abort();
    }
    //wrappedMutexLock(&enemyListLock);
    newEnemyQueue->e = e;
    newEnemyQueue->next = NULL;
    //wrappedMutexUnlock(&enemyListLock);
    return newEnemyQueue; // node created and return it
}

/********************************************************** 
    Insert a new created caterpiller into the caterpiller Linked
    list.
 **********************************************************/
void insertEnemyQueue(enemy *e, enemyNode *enemyQueue) {
    enemyNode *newEnemyQueue = createEnemyQueue(e);
    while(enemyQueue->next != NULL) {
        //wrappedMutexLock(&enemyListLock);
        enemyQueue = enemyQueue -> next;
        //wrappedMutexUnlock(&enemyListLock);
    }
    //wrappedMutexLock(&enemyListLock);
    enemyQueue->next = newEnemyQueue;
    //wrappedMutexUnlock(&enemyListLock);
}

/********************************************************** 
    Delete a caterpiller based on its thread # from the caterpiller
    Linked List.
 **********************************************************/
void deleteEnemy(enemy *e) {
    while(enemyQueue != NULL) {
        if(enemyQueue->e->isDead) {
            pthread_cancel(e->thread);
            pthread_join(e->thread, NULL);
            free(e);
        }
        enemyQueue = enemyQueue -> next;
    }
}

/********************************************************** 
    Get the head pointer to the enemy Linked list
 **********************************************************/
enemyNode* getEnemyQueue() {
    return enemyQueue;
}



/********************************************************** 
    Initializing and creating new enemy bullets and enemy bullet
    threads. 
    Also manages creating Bullet Linked List (if enemy bullet appears first)
    and inserting new enemy bullets into the Bullet Linked List.
 **********************************************************/
void spawnEnemyBullet(int startRow, int startCol, player *p, pthread_mutex_t *screenLock)
{
    enemyBullet* eb = (enemyBullet*)(malloc(sizeof(enemyBullet)));
    /* error checking */
    if (eb == NULL) {
        fprintf(stderr, "Fatal: failed to allocate %zu bytes.\n", sizeof(enemyBullet));
        abort();
    }
	eb->startCol = startCol;
	eb->startRow = startRow;
	eb->mutex = screenLock;
    eb->llist = &bulletListLock;
    eb->p = p;

    wrappedMutexInit(&bulletListLock, NULL); // Initialize bulletListLock
	wrappedMutexInit(eb->mutex, NULL);
	wrappedPthreadCreate(&(eb->thread), NULL, runEnemyBullet, (void*)eb);

    if (bulletQueue == NULL) {
        //wrappedMutexLock(&bulletListLock);
        bulletQueue = createBulletQueue(NULL, eb);
        //wrappedMutexUnlock(&bulletListLock);
    }
    else {
        //wrappedMutexLock(&bulletListLock);
        insertBulletQueue(NULL, eb, bulletQueue);
        //wrappedMutexUnlock(&bulletListLock);
    }
}

/********************************************************** 
    Initializing and creating new player bullets and player bullet
    threads. 
    Also manages creating Bullet Linked List (if player bullet appears first)
    and inserting new player bullets into the Bullet Linked List.
 **********************************************************/
void spawnPlayerBullet(int startRow, int startCol, player *p, pthread_mutex_t *screenLock)
{
    //wrappedMutexInit(&bulletListLock, NULL); // Initialize bulletListLock
    playerBullet* pb = (playerBullet*)(malloc(sizeof(playerBullet)));
    /* error checking */
    if (pb == NULL) {
        fprintf(stderr, "Fatal: failed to allocate %zu bytes.\n", sizeof(playerBullet));
        abort();
    }
	pb->startCol = startCol;
	pb->startRow = startRow;
	pb->mutex = screenLock;
    pb->llist = &bulletListLock;
    pb->p = p;

	//TODO: Init mutex...
    wrappedMutexInit(&bulletListLock, NULL); // Initialize bulletListLock
	wrappedMutexInit(pb->mutex, NULL);
	wrappedPthreadCreate(&(pb->thread), NULL, runPlayerBullet, (void*)pb);

    if (bulletQueue == NULL) {
        bulletQueue = createBulletQueue(pb, NULL);
    }
    else {
        insertBulletQueue(pb, NULL, bulletQueue);
    }
}

/********************************************************** 
    Just creates a new Bullet Linked List
 **********************************************************/
BulletNode* createBulletQueue(playerBullet *pb, enemyBullet *eb) {
    BulletNode *newBulletQueue = (BulletNode*)malloc(sizeof(BulletNode));
    /* error checking */
    if (newBulletQueue == NULL) {
        fprintf(stderr, "Fatal: failed to allocate %zu bytes.\n", sizeof(BulletNode));
        abort();
    }
    //wrappedMutexLock(&bulletListLock);
    newBulletQueue->pb = pb;
    newBulletQueue->eb = eb;
    newBulletQueue->next = NULL;
    //wrappedMutexUnlock(&bulletListLock);
    return newBulletQueue; // node created and return it
}

/********************************************************** 
    Insert a new created bullet into the Bullet Linked
    list.
 **********************************************************/
void insertBulletQueue(playerBullet *pb, enemyBullet *eb, BulletNode *BulletQueue) {
    BulletNode *newBulletQueue = createBulletQueue(pb, eb);
    while(BulletQueue->next != NULL) {
        //wrappedMutexLock(&bulletListLock);
        BulletQueue = BulletQueue -> next;
        //wrappedMutexUnlock(&bulletListLock);
    }
    //wrappedMutexLock(&bulletListLock);
    BulletQueue->next = newBulletQueue;
    //wrappedMutexUnlock(&bulletListLock);
}

/********************************************************** 
    Delete a bullet based on its thread # from the bullet
    Linked List.
 **********************************************************/
void deleteBullet(playerBullet *pb, enemyBullet *eb) {
    //BulletNode *jobQueueInProcess = bulletQueue;
    if(pb != NULL) {
        /* Delete a player bullet */
        while(bulletQueue != NULL) {
            if(bulletQueue->pb != NULL) {
                if(bulletQueue->pb->isDead) {
                    pthread_cancel(pb->thread);
                    pthread_join(pb->thread, NULL);
                    free(pb);
                }
            }
            bulletQueue = bulletQueue -> next;
        }
    }
    else if(eb != NULL) {
        /* Delete an enemy bullet */
        while(bulletQueue != NULL) {
            if(bulletQueue->eb != NULL) {
                if(bulletQueue->eb->isDead) {
                    pthread_cancel(eb->thread);
                    pthread_join(eb->thread, NULL);
                    free(eb);
                }
            }
            bulletQueue = bulletQueue -> next;
        }
    }
}

/********************************************************** 
    Get the head pointer to the Bullet Linked list
 **********************************************************/
BulletNode* getBulletQueue() {
    return bulletQueue;
}
#include <stdio.h>
#include <stdlib.h>
#include "centipede.h" 

int main(int argc, char**argv) {
	centipedeRun();
	printf("done!\n");

	return EXIT_SUCCESS;
}
/**********************************************************************
  Module: player.c
  Author: Micah Hanmin Wang

  Contains all the functions related to the player, including initializing
  a new player, initialize the player thread function, player animation, 
  player moves, and killing player (lives--).

  Also contains the thread function for the player thread.

**********************************************************************/

#include "player.h"
#include <stdio.h>
#include <curses.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>

//sample player graphic, 3 tile animation.
char* playerGraphic[PLAYER_ANIM_TILES][PLAYER_HEIGHT] = 
{
    {"/T_T\\",
     "|-o-|",
     "/*^*\\",
	 "|||||"},
    {"/UwU\\",
     "|o--|",
     "/***\\",
	 "|||||"},
    {"/OvO\\",
     "|--o|",
     "/***\\",
	 "|||||"}
};

/********************support functions***************/
/* reset the player state to start */

/********************************************************** 
    Initialize player's initial position (row+col)
 **********************************************************/
void newPlayer(player *p) 
{
	p->row = p->startRow;
	p->col = p->startCol;
	p->animTile = 0;
	p->state = GAME;
}

/********************************************************** 
    Refraw the player based on updated positions.
	Screen lock required.
 **********************************************************/
void _playerRedrawMoved(player *p, int prevRow, int prevCol, bool lock) 
{
	if(lock) {
		/* Lock the screen when redraw (clear_draw) the player */
		wrappedMutexLock(p->mutex);
		consoleClearImage(prevRow, prevCol, PLAYER_HEIGHT, PLAYER_WIDTH);
		consoleDrawImage(p->row, p->col, playerGraphic[p->animTile], PLAYER_HEIGHT);
		wrappedMutexUnlock(p->mutex);
	}
}

/********************************************************** 
    Calls _playerRedrawMoved function to redraw the player 
	based on the updated player's poistions
 **********************************************************/
void playerRedraw(player *p, bool lock) 
{
	_playerRedrawMoved(p, p->row, p->col, lock);
}

/********************************************************** 
    Move (redraw) the player based on the updated player's 
	positions (dRow and dCol)
 **********************************************************/
void playerMove(player *f, int dRow, int dCol) {
	_playerRedrawMoved(f, dRow, dCol, true);
}

/********************THREAD functions***************/

/********************************************************** 
    Initialize and spawn the player, calls the player thread
	function with the created player object passed in.
 **********************************************************/
player* spawnPlayer(int startRow, int startCol, int lives, pthread_mutex_t *screenLock, pthread_cond_t *cond_cv)
{
    player* p = (player*)(malloc(sizeof(player)));
	/* error checking */
    if (p == NULL) {
        fprintf(stderr, "Fatal: failed to allocate %zu bytes.\n", sizeof(player));
        abort();
    }

	p->lives = lives; // Lives Initialized to 4
	p->score = 0; // Score initialized to 0
	p->startCol = startCol;
	p->startRow = startRow;
	p->running = true;
	p->mutex = screenLock;
	p->cond_cv = cond_cv;

	wrappedMutexInit(p->mutex, NULL);
	wrappedPthreadCreate(&(p->thread), NULL, runPlayerT, (void*)p);
	return p;
}

/********************************************************** 
    Player Thread function.
    Initialize the new player. Manages the player's state switch.
	If the player is being hit, respawn the player to the original position.
	If player wins, send the signal.
	Manages the change of animTiles, to let the player animate when redraw.
 **********************************************************/
void *runPlayerT(void *data) 
{
	// Pass the reference to the player p
	player* p = (player*)data;
	/* RESET the player state to start */
	newPlayer(p);
	
	while (p->running && p->lives > 0) 
	{
		switch(p->state)
		{
			case DEAD:
				p->lives--;
				/* Freeze the player when it's being hit */
				sleep(2);
				wrappedMutexLock(p->mutex);
				consoleClearImage(p->row, p->col, PLAYER_HEIGHT, PLAYER_WIDTH); /* Clears the hit position */
				wrappedMutexUnlock(p->mutex);
				p->row = p->startRow;
				p->col = p->startCol;
				wrappedMutexLock(p->mutex);
				consoleDrawImage(p->row, p->col, playerGraphic[p->animTile], PLAYER_HEIGHT); /* Respawns to the original pos */
				wrappedMutexUnlock(p->mutex);
				
				if(p->lives > 0) {
					/* Respawns to the original pos, if player's lives > 0 */
					p->state = GAME; 
				}
				else {
					/* player loses. The signal is sent via keyboard thread. No need to do anything here. */
				}
				break;
			case GAMEOVER:
				/* No enemy left. player wins */
				wrappedMutexLock(p->mutex);
				putBanner("You win!!!");
				wrappedMutexUnlock(p->mutex);
				/* Send the signal to let the main program wake up & do the clean up */
				wrappedCondSignal(p->cond_cv);
			default:
				;
		}

		/* Make the spaceship animation */
		wrappedMutexLock(p->mutex);
		p->animTile++;
		p->animTile %= PLAYER_ANIM_TILES;
		wrappedMutexUnlock(p->mutex);

		playerRedraw(p, true);
		sleepTicks(PLAYER_ANIM_TICKS);
	}
	pthread_exit(NULL);
}

/********************************************************** 
    Kill the player when its being hit by an enemy bullet.
	Switch the player's STATE to DEAD
 **********************************************************/
void killPlayer(player* p) {
	p->state = DEAD;
}/**********************************************************************
  Module: threadwrappers.h
  Author: Daniel Rea 

  Purpose: error-checking wrappers for pthread functions
	For distribution to students. Not all functions implemented.
	This is just from my solution with parts removed. 
  	Treat it as a guide. Feel free to implement,
	change, remove, etc, in your own solution.

**********************************************************************/
#include <errno.h>
#include <stdio.h>
#include "threadwrappers.h"

int statusCheck(int s)
{
	if ((errno = s) != 0)
		perror(NULL);
	return s;
}

int wrappedPthreadCreate(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)
{
	return statusCheck(pthread_create(thread, attr, start_routine, arg));
}

int wrappedPthreadJoin(pthread_t thread, void **retval) {
	return statusCheck(pthread_join(thread, retval));
}



int wrappedMutexInit(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr) {
	return statusCheck(pthread_mutex_init(mutex, mutexattr));
}

int wrappedMutexLock(pthread_mutex_t *mutex) {
	return statusCheck(pthread_mutex_lock(mutex));
}

int wrappedMutexUnlock(pthread_mutex_t *mutex) {
	return statusCheck(pthread_mutex_unlock(mutex));
}



int wrappedCondSignal(pthread_cond_t *cond) {
	return statusCheck(pthread_cond_signal(cond));
}

int wrappedCondWait(pthread_cond_t *cond, pthread_mutex_t *mutex) {
	return statusCheck(pthread_cond_wait(cond, mutex));
}

/*
add other helper functions here like 

mutex init
mutex lock
mutex unlock 
thread join,
signal,
wait,
etc
etc
*/